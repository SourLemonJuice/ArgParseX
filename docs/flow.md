# 处理流程

## 符号检测

在所有的匹配之前会先检测该字符串是否完全匹配某个特定的符号，比如 `--`

## 组的检测

得到一个全新的 arg 后首先要做的是检测它的前缀。\
我会比较喜欢用 GNU 和 UNIX 风格的想法来思考问题，所以，就像这样：

```bash
cmd --test
```

这其中的 `--` 就是判断它属于哪一个组的决定因素，比如：

```bash
cmd -t
```

这里的 `-t` 就会被识别成其他的组中。\
每个组的前缀是唯一的，这就像是它们的标识符一样重要

这套逻辑中有一个漏洞：为什么假定一个标志必须需要一个前缀？\
BSD 风格的参数就是这样...

但这是个“通用”的库，不管这有多糟糕也都是要实现的呀。\
首先，在遍历 group 的列表时如果找到了前缀为空的条目，就把它的索引记录下来，如果这个参数接下来没有匹配到任何的组就使用这个无前缀的组

不过现在每次都需要遍历整个 group 列表的做法确实很笨，也和未来的内置组有些许冲突。但目前，它应该能用

## 赋值符号

赋值符号结束于标志名称后，它对于独立标志而言：

```bash
cmd --test=testStr
```

通过它可以找到一个有参数的标志中，**名称**到底有多长，并用此去匹配各个配置中的名称

但对于可组合标志而言，出现了赋值符号可不意味着这样：

```bash
cmd -abct=tStr
```

此时整个 arg 中包含**名称**的部分只能被定位到 `abct`，即前缀结尾，赋值符号以前。\
如果这样，怎么定位每一个可组合标志的名称呢

## 可组合标志的名称匹配

大多参数风格中的可组合标志都只允许单个字符作为标志名称，但我想把选择权交给使用者。\
之前的匹配方式是遍历所有标志配置，如果某一个配置的名称与当前输入匹配就立即返回配置数据

但，假设我们有一个字符串，其中包含了长度不等的子串，子串（TestHello）中可能会与另一个子串（Test）重叠一部分。\
这该怎么办，`--TestHello` 很有可能被当成 `--Test` 看待

解决办法之一是在遍历配置列表时不再匹配后立即返回，而是将其长度存起来继续遍历，在最后再将可匹配的最长的条目返回。\
优化是后话，但这里还有一个大问题：为什么假定可组合标志的名称中只有**名称**部分

Windows/DOS 的风格发起了这份质疑：

```text
cmd /A/B
```

这也需要在可组合标志的范畴内...\
所以现在，我们还需要实现用标志前缀分割不同名称的功能。各个函数见的调用已经开始有点乱和复杂了。\
名称匹配部分算是要重新捋一捋咯

来说说参数获取吧

## 标志参数参数与动作

每个标志都可以定义**一个**动作，它将在标志匹配后触发。\
标志参数获取是其中唯一一个会影响到 arg 的长相的

首先是参数的起始点：

```bash
cmd --param=testStr
#
cmd --param testStr
```

这两种格式都需要是能被接受的，至少 GNU 风格就是这样。\
这种行为可以难得的使用 `ARGPX_GROUP_MANDATORY_ASSIGNER` 组属性来进行控制。\
在 static 函数们的领域中，`ActionParamAny_()` 会检测上级调用者是否提供了参数的起始位置，如果没有则跳到下一个 arg 上作为起始位置

那么，多参数呢。\
这是个很不常用的类型，但确实最早被考虑和实现的东西，当时也还没想好 Action 这个名字呢。\
嘛... 总之，多参数也有和赋值符号类似的两种风格：

```bash
cmd --param=str1,str2
cmd --param=str1 str2
```

空格与分隔符(delimiter)\
很简单的逻辑就是啦，检测到分隔符后也就知道了参数的起点和长度，继续下去就行。\
这部分也确实没什么好说的了

值得注意的是，一旦确认了某一种分割行为，后面的参数就不能以另外一种行为进行分割。\
比如 `--param=str1,str2 str3` 就会被认为是参数不足

和赋值符号一样，是否允许使用空格分割的行为也可以使用 `ARGPX_GROUP_MANDATORY_DELIMITER` 组属性进行控制

## 可组合标志的参数获取

一般来说并不应该有什么区别的。\
目前的想法有这几种：

```bash
cmd -at=Str1,Str2
cmd -at Str1,Str2
cmd -atStr1,Str2
```

不过它们的配置方式还没有想好

但这不是重点，多问问自己，为什么：要假定一个可组合参数后不能有其他可组合参数？\
很容易反驳，因为分不清那到底是参数还是标志名称。\
但想想 Windows/DOS 的风格，还能这样：

```text
cmd /Astr/B
```

其中 `str` 是 `/A` 的参数，而且 `/B` 也可以被正常解析。\
救命...

还要判断一下参数的字符串中是否包含了标志组的前缀。\
但只要实现了这些，应该就够了吧...
